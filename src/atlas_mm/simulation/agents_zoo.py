"""Background trading agents that populate the simulation."""

from __future__ import annotations

from abc import ABC, abstractmethod
from dataclasses import dataclass

import numpy as np

from ..engine.orders import OrderType, Side


@dataclass
class AgentOrder:
    """Order generated by a background agent."""

    side: Side
    price: float | None
    quantity: int
    order_type: OrderType


class BackgroundAgent(ABC):
    """Base class for background agents."""

    def __init__(self, agent_id: str, seed: int | None = None) -> None:
        self.agent_id = agent_id
        self.rng = np.random.default_rng(seed)

    @abstractmethod
    def act(self, mid_price: float, tick_size: float, dt: float) -> list[AgentOrder]:
        """Generate orders for this time step."""
        ...


class NoiseTrader(BackgroundAgent):
    """Trades randomly. Represents uninformed liquidity."""

    def __init__(
        self, agent_id: str = "noise", arrival_rate: float = 2.0, seed: int | None = None
    ) -> None:
        super().__init__(agent_id, seed)
        self.arrival_rate = arrival_rate

    def act(self, mid_price: float, tick_size: float, dt: float) -> list[AgentOrder]:
        n = self.rng.poisson(self.arrival_rate * dt)
        orders = []
        for _ in range(n):
            side = Side.BID if self.rng.random() < 0.5 else Side.ASK
            orders.append(
                AgentOrder(
                    side=side,
                    price=None,
                    quantity=int(self.rng.integers(1, 5)),
                    order_type=OrderType.MARKET,
                )
            )
        return orders


class MomentumTrader(BackgroundAgent):
    """Buys on up moves, sells on down moves. Represents informed flow."""

    def __init__(
        self,
        agent_id: str = "momentum",
        lookback: int = 20,
        threshold: float = 0.001,
        arrival_rate: float = 1.0,
        seed: int | None = None,
    ) -> None:
        super().__init__(agent_id, seed)
        self.lookback = lookback
        self.threshold = threshold
        self.arrival_rate = arrival_rate
        self._price_history: list[float] = []

    def act(self, mid_price: float, tick_size: float, dt: float) -> list[AgentOrder]:
        self._price_history.append(mid_price)
        if len(self._price_history) < self.lookback:
            return []

        ret = (mid_price - self._price_history[-self.lookback]) / self._price_history[
            -self.lookback
        ]
        orders = []

        n = self.rng.poisson(self.arrival_rate * dt)
        for _ in range(n):
            if ret > self.threshold:
                orders.append(
                    AgentOrder(
                        side=Side.BID,
                        price=None,
                        quantity=int(self.rng.integers(1, 8)),
                        order_type=OrderType.MARKET,
                    )
                )
            elif ret < -self.threshold:
                orders.append(
                    AgentOrder(
                        side=Side.ASK,
                        price=None,
                        quantity=int(self.rng.integers(1, 8)),
                        order_type=OrderType.MARKET,
                    )
                )

        # Keep history bounded
        if len(self._price_history) > self.lookback * 2:
            self._price_history = self._price_history[-self.lookback :]

        return orders


class MeanReversionTrader(BackgroundAgent):
    """Buys on dips, sells on rallies. Provides liquidity."""

    def __init__(
        self,
        agent_id: str = "mean_reversion",
        lookback: int = 50,
        threshold: float = 0.002,
        seed: int | None = None,
    ) -> None:
        super().__init__(agent_id, seed)
        self.lookback = lookback
        self.threshold = threshold
        self._price_history: list[float] = []

    def act(self, mid_price: float, tick_size: float, dt: float) -> list[AgentOrder]:
        self._price_history.append(mid_price)
        if len(self._price_history) < self.lookback:
            return []

        mean = np.mean(self._price_history[-self.lookback :])
        deviation = (mid_price - mean) / mean
        orders = []

        if deviation < -self.threshold:
            # Price below mean -- buy
            price = mid_price - tick_size
            price = round(round(price / tick_size) * tick_size, 10)
            orders.append(
                AgentOrder(
                    side=Side.BID,
                    price=price,
                    quantity=int(self.rng.integers(3, 10)),
                    order_type=OrderType.LIMIT,
                )
            )
        elif deviation > self.threshold:
            # Price above mean -- sell
            price = mid_price + tick_size
            price = round(round(price / tick_size) * tick_size, 10)
            orders.append(
                AgentOrder(
                    side=Side.ASK,
                    price=price,
                    quantity=int(self.rng.integers(3, 10)),
                    order_type=OrderType.LIMIT,
                )
            )

        if len(self._price_history) > self.lookback * 2:
            self._price_history = self._price_history[-self.lookback :]

        return orders
